RabbitMQ
1. 为什么要使用RabbitMQ
   场景: 当一个服务中的数据修改,相继另一个服务也要跟着修改的时候,我们的解决方案有两种:
        <1> 在修改当前服务数据的时候,也修改直接修改另一个服务的数据
        <2> 在修改当前服务数据的时候,通过Feign调用另一个服务的接口,完成数据修改
   这两个方案的缺陷都是让服务直接产生了高度耦合,微服务的特点就是:高内聚,低耦合,这样就违背了微服务的特性
   最终解决方案: 引入消息中间件,修改方发送一条修改的消息给到中间件,需要修改方接受这条消息并进行修改,这个就
                做到了服务直接解耦操作,同时需要修改方对数据修改成功与否就与我没有任何关系了

2. 消息队列(MQ)
    消息队列是典型的生产者和消费者模型,生产者不断的向到消息队列中生产数据,消费者不断的从消息队列中读取消息.
    因为生产者和消费者都是异步的,而且只关心消息的发送和接收,没有业务逻辑的侵入,这样就实现了生产者和消费者的解耦

3. AMQP和JMS
    消息队列实现的方式有两种: AMQP 和 JMS
    两者的区别:
    <1> AMQP是协议层的,JMS是接口层的
    <2> AMQP是跨语言的,JMS只支持java语言
    <3> JMS只支持两种消息模型,而AMQP的消息模型则更加丰富

4. 常见的MQ产品
    kafka: 分布式消息系统,高吞吐量
    ActiveMQ: 是JMS的一款产品
    RabbitMQ: 是AMQP的一款产品
    RocketMQ: 基于JMS,是阿里巴巴的一款产品

5. RabbitMQ
   简述: AMQP是一种协议,一种规范,它下面有一款产品加RabbitMQ
   官网： http://www.rabbitmq.com/
   官方教程：http://www.rabbitmq.com/getstarted.html

6. 消费者的消息确认机制
    简述: RabbitMQ怎么知道消息有没有被接收呢
    这就要通过消息确认机制来实现了,当消费者获取到消息之后,会向RabbitMQ发送回执ACK,告诉消息被接收了
   回执ACK有两种:
   <1> 自动回执ACK: 一旦消息被接收,消费者自动发送ACK(不管消费者有没有消费或者消费者过程中出现异常)
                   给RabbitMQ,RabbitMQ会将消息从消息队列中删除
   <2> 手动回执ACK: 消息接收后不会发送ACK,需要手动调用发送,当消费者真正消费完消息之后再回执ACK给RabbitMQ

7. 五种消息模型
7.1 基本消息模型
    简述: 生产者生产消息到队列中,消费者从队列中获取消息并消费,这里是一个队列对应一个消费者

7.2 work消息模型
    简述: 当消息处理非常耗时的时候,生产者生产消息的速度远远大于消费者消费消息的速度,长此以往下去,堆积的消息
         会越来越多,无法及时处理.此时就可以使用work消息模型,将多个消费者绑定到同一个消息队列中,共同消费队列
         中的消息.队列中的消息一旦消费则会消失,不会出现重复消费的情况
    原理: 多个消费者指定同一个队列,从队列中获取消息
    <1> 贪吃机制
        如果在消费者中不设置每次消费只获取一条消息,那么就会出现以下情况:
        如果有50条消息,两个消费者,此时就会发现在队列中消息会立马清空,两个消费者会各占25条数据,然后进行消费,
        这种情况是不好的,如果一个消费者消费快,一个消费者消费慢,那消费者快的则很快消费完,而消费者慢的则很久才
        消费完,对于这个消息消费耗时是非常长的,显然这种贪吃机制是不合理的
    <2> 能者多劳机制
        为解决以上问题,则进行优化,在消费者中进行设置,每次消费者消费时只获取一个消息,那这样的话消费者快的则可以
        消费更多消息,消费者慢的就消费少点,这样做的消息消费耗时是非常短的,这就是能者多劳机制

7.3 订阅消息模型
    为什么有订阅消息模型?
    简述: 在以上work消息模型中我们可以发现一个生产者只能对应一个队列,那可不可对应多个队列呢,此时则有了订阅消息
          模型,将消息不再发送至队列中,而是交换机中,通过交换机中不同类型来路由分配给队列,生产者将消息交给交换机,
          消费者从队列中获取消息
     注: 交换机是没有存储消息的能力,只有队列才有存储消息的能力,当交换机没有绑定队列时,生产者将消息发送给交换机中时,
         消息会自动消亡
    交换机类型:
    <1> fanout(广播): 将消息路由分配给所有绑定到交换机的队列中
    <2> Direct(定向): 把消息路由分配给符合指定RoutingKey的队列
    <3> Topic(通配符): 把消息路由分配给符合路由规则的队列

8. 消息持久化
    如何避免消息丢失
    简述: 如果RabbitMQ异常则MQ中的消息就会消亡,此时我们要进行消息持久化,对交换机,队列及消息进行持久化

9. spring整合RibbitMQ
   步骤:
   <1> 引入amqp启动器
   <2> yml配置中配置MQ连接信息
   <3> 引入AMQPtemplate,通过AMQPtemplate.convertAndSend发送消息,指定交换机,路由规则,消息
   <4> 写个MQ监听器,通过监听器接受消息
   这里是生产者和消费者写在了一起,实际应用中则需要在生产者服务中发送消息,在消费者服务中接受消息

10. 常见问题
    <1> 交换机如果没有绑定队列,那么消息就会消亡,交换机不能存储消息的,只有队列才能存储消息
    <2>  一个队列中有多个消费者,同一个消息只能被一个消费者所消费,想要多个消费者消费同一条消息,
        那么我们可以通过交换机把消息分发到多个队列中,供多个消费者消费
    <3>