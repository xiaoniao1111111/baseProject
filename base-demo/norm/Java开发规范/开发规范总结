编程规范:
1. 命名风格
    1.1  代码中的命名均不能以下划线,美元符开始和结束
        反例:  _xxx  xxx_  $xxx  xxx$

    1.2  代码中的命名禁止拼音和英文混合使用,更不能直接使用中文的命名方式
        反例:  getPingFenByName (获取评分)

    1.3  类名使用UpperCamelCase(大驼峰)风格 但以下例外: DO / BO / DTO / VO / PO 等
        反例:  userDO   USERDo    正例: UserDO

    1.4  方法名,成员变量,参数名,局部变量都统一使用lowerCamelCase(小驼峰)命名风格
        反例: GetUserName   正例:  getUserName

    1.5  常量命名全部大写,单词间用下划线隔开,力求语义表达完整,不要嫌名字长
        反例:  FixedFee      正例: FIXED_FEE    (固费)

    1.6  抽象类命名以Abstract或Base开头,异常类命名使用Exception结尾,测试要以Test结尾
        反例: UserBase        正例: BaseUser    (抽象举例)
          UserEx                UserException    (异常举例)
          User                  UserTest        (测试举例)

    1.7  Boolean 定义的属性名 不能以is开头,这样部分框架解析会引起序列化错误
        反例:  Boolean  isDeleted ; 他的方法也是"isDeleted",RPC框架在反向解析的时候"误以为"对象的属性名称为"delete"
        导致属性获取不到,进而抛出异常

    1.8  包名统一小写且都是单数,不存在复数形式

    1.9  如果模块.接口.类.方法使用了设计模式,在命名时需要体现出具体模式
        正例:  UserFactory   (用户工厂模式)

    2.0  接口类中的方法变量不要加任何修饰符(public),保持代码的简洁性

    2.1  接口和实现类的命名规则
          接口: 正常的业务名     实现类:  在接口的业务名后面加上Impl

    2.2  枚举类命名结尾要加上Enum,枚举的成员名称要全部大写,各个单词间要使用下划线

    2.3  各层命名规范
    A) Service/DAO层方法命名规范:
      <1>   获取单个对象  get前缀
      <2>   获取多个对象  list前缀后缀复数形式     listObjects
      <3>   获取统计值    count前缀
      <4>   插入的方法   save/insert前缀
      <5>   删除的方法   remove/delete前缀
      <6>   更新的方法   update前缀
    B) 领域模型命名规范
       <1>  数据对象:   xxxDO     (数据表明->与数据库表字段一一对应形成的对象叫DO)
       <2>  数据传输对象: xxxDTO   (从数据库获取的数据封装成对象给service层,这个对象就是DTO,简单来说就是接受数据库数据的对象)
       <3>  展示对象:   xxxVO   (后端将页面上展现的数据封装起来传给前端的对象叫VO)
       <4>  POJO是 DO/DTO/BO/VO的统称,禁止命名为xxxPOJO
       <5>  业务逻辑对象: xxxBO   (将获取或处理的多个对象封装成一个对象保存起来叫BO)

2.  常量定义
    2.1 不允许魔法值直接出现在代码中(即未预先定义的常量)
        反例: String key="常量"+tradeId;

    2.2 在给Long或long赋值时,单位长度要大写
        正例: Long height=4L;

    2.3 不要使用一个常量类来维护所有的常量,要按照常量功能进行分类,分开维护

    2.4 常量的复用层次有五层:
        跨应用共享常量,应用内共享常量,子工程内共享常量,包内共享常量,类内共享常量
        应用场景:   当整个项目都需要统一的常量则在整个项目下的constant   如果作用在这个功能或这个包里面则在包中的constant
        扩展: 类里面的常量要注释用意

3.  代码格式
    3.1 大括号规定: 大括号内为空,则直接{},不用跨行

    3.2  左右小括号与字符之间不需要空格,左大括号前面需要空格
        反例: if ( a == b ){;         正例:    if (a == b) {

    3.3 if/for/while/switch/do  这些保留字要和括号之间保留空格

    3.4 两目,三目运算符左右都必须加空格
        说明: 有逻辑运算符(&& ||)  赋值运算符(= += -= /=)  算数运算符(加减乘除)

    3.5 注释与内容之间有且仅有一个空格

    3.6 单行不能超过120个字符,超出需换行,换行时遵循以下规则:
        <1> 第二行要缩进4个空格,也就是一个tab(后退)
        <2> 换行前如有".",在"."前面换行
        <3> 如有运算符,运算符与下文一起换行
        <4> 如有",",在","后换行

    3.7 方法中当有多个参数时,用逗号隔开且每个逗号后面都要空格

    3.8 单个方法总行不能超过80行;代码的逻辑要分清红花和绿叶,绿叶的逻辑我们要单独拎出来作为额外方法,
            使主干方法更加清晰,共性逻辑要抽取为公性方法,便于复用和维护

    3.9 不同逻辑,不同语义,不同业务代码上下之间插入一个空行,便于可读性

4.  OOP规约
    4.1 equals的使用,为了防止空指针异常,应使用常量或确定有值的对象来调用equals
        反例: a.equals("test")         正例:  "test".equals(a)

    4.2 所有的相同类型的包装类对象之间比较使用equals

    4.3 关于基本数据类型与包装数据类型的使用标准如下:
        <1> 所有的POJO类属性必须使用包装数据类型
        <2> RPC方法的返回值和参数必须使用包装数据类型
        <3> 所有的局部变量使用基本数据类型

    4.4 POJO类必须复写toString方法

    4.5 当一个类有多个同名方法时,应放在一起便于阅读

    4.6 循环体内,字符串的连接方式,使用StringBuilder的append方法进行扩展.

5.  集合处理
    5.1 本身集合做添加和删除要使用iterator,不要使用foreach方式

    5.2 利用set的唯一性,可以快速对一个集合进行去重操作,避免使用list的contains方法进行遍历.对比.去重

6.  并发处理
   待深究

7.  控制语句
    7.1 在一个switch块中,要么用break/return终止,要么通过注释说明到那个break结束,同时都必须包含一个default语句
        放在最后,即使是空代码

    7.2 在if/else/for/while/do语句中必须使用大括号,即使只有一行代码,避免使用单行的代码

    7.3 表达异常分支时,少用if....else方式,这种方式可以改写为:
        --例子见测试
       注意:  如果非要使用if...elseif...elseif....else..这种业务逻辑,请勿超过3层,超过3层建议使用卫语句,
              策略模式,状态模式等来实现

    7.4 循环体的语句要考量性能,以下操作尽量移至循环体外处理,如定义对象,变量,获取数据库连接,
        进行不必要的try-catch操作(这个try-catch操作是否可以移至循环体外)

    7.5 避免采用取反逻辑运算符
        说明: 取反逻辑不利于快速理解,并且取反逻辑写法必然存在对应的正向逻辑写法
        --例子见测试

8. 注释规约
    8.1 类,类属性,类方法  要用"/**xxxxxx**/"的注释,便于阅读,不得使用"// xxx "形式注释,
        方法内部单行注释

    8.2 所有的抽象方法必须要用javadoc注释,除了返回值,参数,异常说明外,还必须指出该方法做什么事情,实现什么功能
        补充: javadoc注释--第一行简述该功能或作用,第二行详细说明,第三行参数描述,第四行返回值描述
        第五行异常类描述,同时最后可以加上版本号和作者

    8.3 所有的枚举字段必须要有注释,说明每个数据的用途

    8.4 代码修改的同时,注释也要相对应的修改,尤其是参数,返回值,异常及核心逻辑的修改

二. 异常日志
    1. 异常不要用来做流程控制,条件控制
        说明: 异常设计的初衷是用来解决程序运行过程中的各种意外情况,且异常处理效率比条件判断方式要低很多

    2.  catch要分清稳定代码和非稳定代码

    3.  有try块放到了事务代码中,catch异常后,如果需要回滚事务,一定要注意手动回滚事务

    4.  不要再finally块中使用return

    5.  捕获异常和抛异常一定要完全匹配,或者是捕获异常或抛异常的父类
        说明: 如果预期抛的是绣球,接到的却是铅球,就会产生意外情况

三.  日志规约
    1.  应用中不可直接使用日志系统(Log4j,Logback)中的API,而是使用日志框架Slf4j中的API,有利于维护和各个类的日志处理方式统一.

    2.  日志至少保存15天,因为有些异常是以"周"为频次发生的特点

    3.  尽量使用携带路径的日志方式

    4.  info/debug级别的日志尽量使用站位符方式打印日志
        eg: logger.info("xxxxName:{} and xxxxID:{}",name,id)

    5.  避免重复打印log日志,浪费磁盘空间,additivity=false

    6.  尽量用全英文来描述日志错误信息,如果英文描述不清楚可用英文描述即可

四.  单元测试
    1.  好的单元测试必须遵守AIR原则
        说明: 好的单元测试具有自动化,独立性,可重复执行的特点
        A(Automatic):   自动化
        I(Independent): 独立性
        R(Repeatable):  可重复

    2.  单元测试应该是全自动化的,执行过程中应该是全自动化,通过测试的结果不应该是通过"System.out"来进行人肉验证,必须使用assert来验证

    3.  保证单元测试的独立性,

    4.  单元测试是可以重复执行的,不能受外界环境的影响
        说明: 如果单测对外部环境(网络,服务,中间件)有依赖,容易导致持续集成机制的不可用
        正例: 为了不受外部环境影响,要求设计代码时就把SUT的依赖改成注入,在测试时用spring这样的DI框架注入一个本地(内存)实现或者Mock实现

    5.  对于单元测试,要保证颗粒度足够小,有助于精确定位问题.单测粒度至多是类级别,一般是方法级别
        说明: 只有颗粒度小才能在出错时尽快定位到出错位置,单测不负责跨类,跨系统的交互逻辑,那是集成测试的领域

    6.  新增代码及时补充单元测试,修改代码影响了原有的单元测试,请及时修正

    7.  单元测试代码必须写test目录下,不能写在业务目录下
