线程池
1.  简述: 如果并发的线程数量很多并且每个线程的执行时间很短,那就需要频繁的创建和销毁线程,这样频繁操作就会大大降低系统的效率
       这时我们可以考虑用线程池来解决,当需要执行任务的时候从线程池中取出线程进行执行,执行任务完成后,线程不用销毁,将它放回
       线程池中,下次还可以继续使用

2.  线程池的作用
    <1> 降低资源销毁,减少了创建和销毁线程的次数,每个线程都可以重复利用,执行多个任务
    <2> 提高响应速度,当任务到达时不需要等待创建线程可以立马被执行
    <3> 提高可管理性,可以根据系统的承受能力来调整线程池中的线程数量,防止线程数量过多消耗更多的内存,线程开的越多,消耗内存就
        越大,最后可能导致死机或宕机

3. 线程池的创建
    通过Executors工具类来创建线程池对象
    <1> 获取线程池对象
        ExecutorService es = Executors.newFixedThreadPool(2);
    <2> 从线程池中获取线程来执行任务
        es.execute(stt);

4. 线程异步和同步
    synchronized(同步的)、asynchronized(异步的)
    多个线程同时操作数据库的时候
    异步编程(CompletableFuture)

5. 创建线程池的几种方式
    <1> 固定线程池: Executors.newFixedThreadPool();
        简述: 创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待

    <2> 缓存线程池: Executors.newCacheThreadPool();
        简述: 创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程

    <3> 单列线程池: Executors.newScheduledThreadPool
        简述: 创建单个线程数的线程池，它可以保证先进先出的执行顺序

    <4> 手动创建线程池: new TreadPoolExector();

    区别: 固定线程池: 如果线程数已满,队列一直存放任务,任务量大则会导致OOM
         缓存线程池: 当任务量过大,此时一直创建线程,则会导致OOM
         手动创建线程池: 使用它可以明确线程池的运行规则，规避资源耗尽的风险。

6. TreadPoolExector
    <1> 参数介绍
        1) corePoolSize: 核心线程池的大小
        2) maximumPoolSize: 最大线程数
        3) keepAliveTime: 当线程池中线程数大于corePoolSize，并且没有可执行任务时大于corePoolSize那部分线程的存活时间
        4) unit：keepAliveTime的时间单位
        5) workQueue：用来暂时保存任务的工作队列
        6) threadFactory: 线程工厂提供线程的创建方式，默认使用Executors.defaultThreadFactory()
        7) handler: 当线程池所处理的任务数超过其承载容量或关闭后继续有任务提交时，所调用的拒绝策略

    <2> corePoolSize
        1) 线程数量小于corePoolSize
          当提交一个任务时,此时的线程数小于核心线程数,则创建一个线程执行任务

        2) 线程数量介于corePoolSize与maximumPoolSize之间,且阻塞队列未满
          此时会将任务放入到阻塞队列中

        3) 线程数量等于maximumPoolSize,且阻塞队已满满
          则根据构造函数中的 handler 指定的策略来拒绝新的任务。

    <3> 线程池整体工作流程
        1) 如果当前运行线程数小于核心线程数,则创建一个线程来执行任务
        2) 如果当前线程数大于核心线程数,则将任务放入到队列中
        3) 如果队列已满,无法将任务添加到队列时,则创建线程来执行任务
        4) 如果当前运行线程数大于/等于最大线程数的是,调用RejectedExecutionHandler.rejectedExecution()方法,
           执行拒绝策略

    <4> TreadPoolExector执行任务的两种方法
        1) sumbit(); 有返回结果,便于异常处理
        2) execute(); 没有返回结果
        区别: 使用submit方法可以对task执行的结果成功，失败，或者执行过程中抛出的异常及时处理，暂停处理其他task，
              使用execute不能及时处理程序在运行中出现的异常情况

    <5> workQueue(工作队列)
        1) SynchronousQueue
           当有任务到来时,同时当前线程等于核心线程时,此时会创建一个线程来执行任务,与最大线程数没有关系,
           就类似于缓存线程池
        2) LinkedQueue
           当有任务到来时,同时当前线程等于核心线程时,此时会将任务放到队列中
        3) ArrayQueue
           大线程数小队列: 此时如果任务执行快且短暂,会在短时间内提高cup的使用率,理论上可以提高系统的吞吐量,
           如果任务时常阻塞,此时线程数满了,队列满了,进而降低了系统的吞吐量

    <6> hander(策略处理)
        1) AbortPolicy(默认)
           一旦拒绝策略处理,此时就会抛出运行时异常RejectedExecutionException
        2) DiscardPolicy
            一旦拒绝策略处理,此时会将任务丢弃,不做任何处理
        3) DiscardOldsetPolicy
            一旦拒绝策略处理,经工作队列头部的任务丢弃,然后重试执行(可能会再次失败,导致这个重复)

