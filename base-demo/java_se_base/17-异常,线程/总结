异常:
1.  简介
    异常超类: Throwable  下面两大子类: Error (严重错误)    Exception(异常)

    Execption异常类下面包含两大类异常: 编译时异常 和 运行时异常(RuntimeException)

2.  异常抛出原理:
     第一步: 具体方法出现异常后,无法处理,抛给调用方
     第二步: 调用方拿到异常后也处理不了,抛给main方法
     第三步: main方法处理不了会抛给jvm,由于jvm已经是底层了不能再抛了,所有将异常信息打印到控制台上

3.  异常打印的控制台会提供三种信息:
    1. 异常原因  2. 异常类型   3. 异常的位置

4.  异常的处理方式有两种:
    1. 声明:  通过throws声明给调用方
    2. 捕获: 对异常进行捕获,捕获的异常可以进行抛出(throw),也可以进行自定义处理

5.  finally
    简述: 不管当前捕获的代码是否有异常,最终都会执行finally方法体中的代码块

6.  异常注意事项
    子类继承父类的方法,在复写的方法中出现异常时不能声明,只能捕获

线程
1.  线程,进程
    进程: 正在运行的程序叫进程
    线程: 进程中每一个任务叫做线程
    多线程: 一个进程中多个线程(任务)正在运行,成为多线程
    线程调度: 说白了就是那个线程被CPU来执行
    线程调度分为:
    分时调度模型: 多个线程轮流拥有CPU的使用权,平均分配每个线程使用CPU的时间
    抢占式调度模型: 那个线程的优先级高,那个线程先被CPU执行,从低到高,1-10,默认优先级是5

2.  并行和并发
    并行: 两个或多个事件同一时刻执行(秒级,毫秒级)
    并发: 两个或多个事件同一时间段执行(比如9点-12点)

3.  创建线程方式一
      1. 自定义线程类继承Thread,这个类就叫线程类
      2. 复写Thread类中的run()方法,run方法中用来书写具体的业务
      2. 在main方法中创建自定义线程类,
      4. 调用start()方法,启动线程
      注: 当启动线程后,jvm会自动调用自定义类的run方法,run方法的本身来自于Thread类

4.  线程方法总结
    Thread.currentThread()  获取当前线程对象
    getName();  获取线程名字
    setName();  设置线程名字
    sleep(); 将线程睡眠/等待一段时间后再去执行,单位是毫秒

5.  创建线程方式二
    1. 创建自定义类实现Runable接口,作为任务类
    2. 复写run方法,书写具体业务
    3. 创建自定义线程类
    4. 创建Thread线程对象,将任务类作为参数传递
    5. 启动线程
    // 参数一: 任务类对象   参数二: 线程名字
    Thread thread = new Thread(new MyTask(),"创建线程类方式二");
    thread.start();
    方式二的好处:
    1. 避免单继承的局限性
    2. 解耦合,方式一中: 任务和线程在一起书写耦合性高  方式二: 任务和线程是分开的

6.  多线程安全问题
    <1> 获取数据重复或跳票
    数据重复-现象: 由于同一时间多个线程获取的是同一个数据
    跳票-现象: 第一个线程在相减后,cup切换到另一个线程此时拿到的值是线程一计算后的,这时在这个结果上面做了相减操作,
    cpu又切换至另一个线程也做了同样的操作,当下一个线程获取票数的时候就会出现跳票的情况了.
    解决方案:
    加同步代码块,关键字: synchronized

    <2> 同步方法
    简述: 之前只要在同步代码块中的代码都会同步执行,那么我们把这些代码封装成一个方法,然后在方法加上synchronized修饰符,
    此时这个方法就是同步方法了,这个也是同步代码块的升级版本
    注: 这个方法中的代码需要同步执行才行,如果不是同步执行需要分开
    <3> 非静态同步方法中的锁是this(对象本身)
    <4> 静态同步方法中的锁是当前类的.class字节码文件对象
    静态方法中是没有this的,静态方法的调用则是类名.方法名
    <5> 创建线程安全的集合和Map
        1) 集合: Collections.synchronizedList(List list)
        2) Map: Collections.synchronizedMap

7.  synchronized和lock锁的区别
    <1> synchronized是关键字,lock是接口
    <2> synchronized可以作用在方法上,也可以作用在代码块,lock只作用在代码块
    <3> synchronized在任务执行完之后会释放锁,而lock需要调用unlock来释放锁
    <4> synchronized的线程通信是通过Object中的wait,notify完成,而lock使用了condition接口中的await,signal来实现

8.  线程通信
    简述: 让线程等待及线程间的相互唤醒就叫线程通信
    模拟场景: 生产者生产手机,消费者消费手机,当没有手机的时候生产者生产手机,生产完手机之后叫消费者使用,
            当有手机的时候,生产者处于无限等待,只有消费者消费完才能再次生产手机

9.  线程的生命周期
    <1> 线程创建: 刚创建线程,线程尚未启动
    <2> 可执行(线程启动): 线程已启动,但未执行run方法
    <3> 锁阻塞: 未获取到锁,则进入等待状态,只有获取到锁才能执行下一步
    <4> 无限等待: 获取到锁之后,调用wait()方法进入无限等待,只有其他线程调用notify方法唤醒该线程,该线程才能争取锁进入一下步的资格
         注: 无限等待中的线程将会释放锁,同时也不会去争取获取锁的机会
    <5> 计时等待: 让线程等待几秒再去执行
    <6> 被终止, 调用run方法已完成或者中间异常则走入到线程终止状态

10. 死锁
    简述: 当一个线程访问另一个线程的资源,而另一个线程也正好访问当前线程的字段,此时最出现了循环等待的情况,最终导致死锁

    <1> 引发死锁的条件
        1) 互斥的作用: 当资源被一个线程占用时其他线程则不能使用
        2) 不可强占资源: 当一个资源被一个线程占用时,别的线程则不能强行夺取这个资源,,只有等这个线程是否锁才可以
        3) 请求和保持: 当一个线程访问其他资源时,该线程中的资源也保持占有
        4) 循环等待
    <2> 最简单的方法: 对锁进行排序
        当两个线程中的锁顺序不一致时,我们可以将他们锁的顺序保持一致,这样就可以避免循环等待的这样现象
