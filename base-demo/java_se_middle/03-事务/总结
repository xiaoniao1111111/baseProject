事务
1.  概述
    事务指的是逻辑上一组操作,组成逻辑的这些操作要么全部成功,要么全部失败
    事务的作用: 保证一个事务中多个操作要么一起成功,要么一起失败

2.  事务的特性
    <1> 隔离性
        简述: 多个用户并发的访问数据库时,一个事务的操作不会被其他事务干扰,事务间相互隔离
               一个事务的成功或失败对于其他事务不会产生影响,事务间应该相互独立
        例子:  事务A: a->b转账    事务B: c->d转账   AB两个事务之间互不影响
    <2> 持久性
        简述: 指一个事务被提交后,它对数据库的操作是永久性的,就是数据出现异常,重启之后数据依然存在
        例子: a事务向数据库中插入一条数据成功后,那么这条数据在数据库是永久存在的,就是数据库出现异常,待恢复正常后,这条数据依然存在
    <3> 原子性
        一个事务中的一组操作,要么都发生,要么都不发生
        例子: A事务中有3条语句分别插入到不同的3张表中,要么全部都操作,要么都不操作,假如中间出现异常那么就都不要成功(所谓的要么全部成功,要么全部失败)
    <4> 一致性
        一个事务在执行前或执行后,数据库都必须处于一致状态
        例子: a有200,b有300,a向b转账100,此时a在数据库中就是100,b在数据库中是400,它们金额总共没有发生变化,也就是数据前后必须处于一致状态
              如果a转账出现异常,或者b接收钱出现异常,那么就全部回滚,保持数据的一致性

3.  事务的隔离级别
    简述: 事务的并发所引发的问题
    <1> 脏读
        简述: 一个事务读了另一事务未提交的数据
        例子: 数据库中有300块,A事务在读的时候,B事务则对300块减去100,此时B事务并没有提交到数据库,而A事务最终拿到的结果就是200
    <2> 不可重复读
        简述: 一个事务前后读取的数据发生了改变,导致读取的结果不一致,这就是所谓的不可重复读,是针对数据发生变化而言的
        数据库中有300块,A事务第一次读的时候是300块,此时B事务对300块减去100并提交至数据库,A事务再次去读取的时候发现是200
    <3> 幻读
        简述: 一个事务前后读取数据的条数发生了改变,此时则出现了幻读
        例子: a事务第一次读取的数据条数是一条,B事务此时增加了3条数据,那A事务再次读取的时候发现数据变成了4条,这就是所谓的幻读

4.  数据库中的4种隔离级别
    <1> read uncommitted 读提交的
        一个事务可以读取另一个事未务未提交的数据
        事务的3中问题都未解决
    <2> read committed 读已提交的
        一个事务可以读取另一个事务已提交的问题
        解决了事务中的脏读,未解决不可重复读和幻读
    <3> repeatable read 可重复读
        一个事务读取数据始终保持一致,不管另一个事务是否已提交
        解决了脏读,不可重复读问题
    <4> serializable  串行化
        多个事务并发操作数据库,每次只能有一个事务进行操作,其他事务排队等待
        解决了脏读,不可重复读,幻读问题

    安全性: 串行化>可重复读>读已提交的>读未提交的
    性能: 读未提交的>读已提交的>可重复读>串行化
    oracle使用的是已提交的级别   mysql使用的是可重复读级别

5.  事务失效的原因
    <1> 事务是否开启
    <2> 该bean是否被事务进行管理
    <3> 该方法是否是非public访问修饰符,因为事务是通过动态代理完成的,动态代理的方法要求是public
    <4> 该方法是否被final修饰,因为final方法是无法重写的,而动态代理是要重写方法的
    <5> 表是myISAM存储引擎,是不支持事务的,所以事务失效
    <6> 手动抛了别的异常,spring事务只会回滚运行时异常和error,对Exception(非运行时异常)是不会回滚的
